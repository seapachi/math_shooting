<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Math Lane Shooter</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&family=Rajdhani:wght@600;700&family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div id="game"></div>

  <!-- Phaser 3 (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script>
    // ===== Utilities =====
    const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const FONT_TITLE = '"Orbitron", "Space Grotesk", sans-serif';
    const FONT_UI = '"Space Grotesk", sans-serif';
    const FONT_ENEMY = '"Rajdhani", "Orbitron", sans-serif';
    const SHIP_STYLES = ["sharp", "flare"];
    let currentShip = "sharp";
    let currentMode = "sub";

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function addStarfield(scene, w, h, count = 140) {
      const g = scene.add.graphics();
      for (let i = 0; i < count; i++) {
        const x = Math.random() * w;
        const y = Math.random() * h;
        const r = Math.random() * 1.6 + 0.3;
        const alpha = Math.random() * 0.6 + 0.2;
        const tint = Phaser.Display.Color.GetColor(180 + randInt(0, 60), 200 + randInt(0, 40), 255);
        g.fillStyle(tint, alpha);
        g.fillCircle(x, y, r);
      }
      return g;
    }

    function makeQuestion(mode = "sub") {
      if (mode === "add") return makeAddQuestion();
      if (mode === "mul") return makeMulQuestion();
      return makeSubQuestion();
    }

    function makeAddQuestion() {
      const a = randInt(0, 9);
      const b = randInt(0, 9);
      const correct = a + b;

      const set = new Set([correct]);
      const deltas = shuffle([-2, -1, +1, +2, -3, +3]);

      for (const d of deltas) {
        if (set.size >= 4) break;
        const v = correct + d;
        if (v >= 0 && v <= 18) set.add(v);
      }

      while (set.size < 4) {
        set.add(randInt(0, 18));
      }

      const choices = shuffle([...set]);
      return { text: `${a} + ${b}`, correct, choices };
    }

    function makeSubQuestion() {
      const a = randInt(0, 20);
      const b = randInt(0, a);
      const correct = a - b;

      const set = new Set([correct]);
      const deltas = shuffle([-2, -1, +1, +2, -3, +3]);

      for (const d of deltas) {
        if (set.size >= 4) break;
        const v = correct + d;
        if (v >= 0 && v <= 20) set.add(v);
      }

      while (set.size < 4) {
        set.add(randInt(0, 20));
      }

      const choices = shuffle([...set]);
      return { text: `${a} - ${b}`, correct, choices };
    }

    function makeMulQuestion() {
      const a = randInt(1, 9);
      const b = randInt(1, 9);
      const correct = a * b;

      const set = new Set([correct]);
      const deltas = shuffle([-3, -2, -1, +1, +2, +3]);
      const near = deltas
        .map(d => correct + d)
        .filter(v => v >= 1 && v <= 81);

      const tableCandidates = [
        a * (b - 1), a * (b + 1),
        a * (b - 2), a * (b + 2),
        b * (a - 1), b * (a + 1),
        b * (a - 2), b * (a + 2)
      ].filter(v => v >= 1 && v <= 81);

      const candidates = shuffle([...near, ...tableCandidates]);
      for (const v of candidates) {
        if (set.size >= 4) break;
        set.add(v);
      }

      while (set.size < 4) {
        set.add(randInt(1, 81));
      }

      const choices = shuffle([...set]);
      return { text: `${a} × ${b}`, correct, choices };
    }
    // ===== SFX (Web Audio synth: punchy shooter) =====
    // iOS requires user gesture before audio can play; we call SFX.resume() on START tap.
    // Picked set: shoot:1 correct:4 wrong:1 miss:2 ui:1
    const AudioLab = (() => {
      let ctx = null;
      let master = null;
      let comp = null;
      let drive = null;

      function makeDriveCurve(amount) {
        const k = typeof amount === "number" ? amount : 20;
        const n = 44100;
        const curve = new Float32Array(n);
        const deg = Math.PI / 180;
        for (let i = 0; i < n; i++) {
          const x = (i * 2) / n - 1;
          curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
        }
        return curve;
      }

      function ensure() {
        if (ctx) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        ctx = new AC();

        master = ctx.createGain();
        master.gain.value = 0.55; // louder / punchier

        comp = ctx.createDynamicsCompressor();
        comp.threshold.value = -18;
        comp.knee.value = 24;
        comp.ratio.value = 6;
        comp.attack.value = 0.004;
        comp.release.value = 0.12;

        drive = ctx.createWaveShaper();
        drive.curve = makeDriveCurve(18);
        drive.oversample = "4x";

        master.connect(comp);
        comp.connect(drive);
        drive.connect(ctx.destination);
      }

      async function resume() {
        ensure();
        if (ctx.state === "suspended") {
          try { await ctx.resume(); } catch (_) {}
        }
      }

      function now() { return ctx?.currentTime ?? 0; }

      function env(g, t0, a, d, s, r, peak = 0.9) {
        g.gain.cancelScheduledValues(t0);
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(Math.max(0.0002, peak), t0 + Math.max(0.001, a));
        g.gain.exponentialRampToValueAtTime(Math.max(0.0002, peak * s), t0 + a + Math.max(0.001, d));
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + a + d + Math.max(0.001, r));
      }

      function osc({ type = "sawtooth", f = 440, fTo = null, dur = 0.12, gain = 0.5, detune = 0 } = {}) {
        if (!ctx || ctx.state !== "running") return;
        const t0 = now();
        const o = ctx.createOscillator();
        const g = ctx.createGain();

        o.type = type;
        o.detune.value = detune;
        o.frequency.setValueAtTime(f, t0);
        if (fTo != null) {
          o.frequency.exponentialRampToValueAtTime(Math.max(1, fTo), t0 + dur);
        }

        env(g, t0, 0.004, 0.03, 0.25, dur, gain);

        o.connect(g);
        g.connect(master);
        o.start(t0);
        o.stop(t0 + dur + 0.08);
      }

      function noise({ dur = 0.08, gain = 0.25, hp = 1200, lp = 8000 } = {}) {
        if (!ctx || ctx.state !== "running") return;
        const t0 = now();
        const n = Math.floor(ctx.sampleRate * dur);
        const buf = ctx.createBuffer(1, n, ctx.sampleRate);
        const d = buf.getChannelData(0);
        for (let i = 0; i < n; i++) d[i] = (Math.random() * 2 - 1);

        const src = ctx.createBufferSource();
        src.buffer = buf;

        const g = ctx.createGain();
        const hpF = ctx.createBiquadFilter();
        const lpF = ctx.createBiquadFilter();
        hpF.type = "highpass";
        lpF.type = "lowpass";
        hpF.frequency.setValueAtTime(hp, t0);
        lpF.frequency.setValueAtTime(lp, t0);

        env(g, t0, 0.002, 0.02, 0.2, dur, gain);

        src.connect(hpF);
        hpF.connect(lpF);
        lpF.connect(g);
        g.connect(master);

        src.start(t0);
        src.stop(t0 + dur + 0.05);
      }

      function click({ f = 900, dur = 0.03, gain = 0.35 } = {}) {
        osc({ type: "square", f, fTo: f * 0.95, dur, gain });
      }

      return { ensure, resume, osc, noise, click };
    })();

    const SFX = (() => {
      const picks = { shoot: 1, correct: 4, wrong: 1, miss: 2, ui: 1 };

      function playShoot1() {
        // plasma zap
        AudioLab.osc({ type: "sawtooth", f: 1800, fTo: 420, dur: 0.09, gain: 0.55, detune: -3 });
        AudioLab.osc({ type: "square", f: 900, fTo: 240, dur: 0.07, gain: 0.25, detune: 7 });
        AudioLab.noise({ dur: 0.05, gain: 0.18, hp: 2200, lp: 9000 });
      }

      function playCorrect4() {
        // happy blip (two notes)
        AudioLab.click({ f: 1040, dur: 0.04, gain: 0.35 });
        setTimeout(() => AudioLab.click({ f: 1560, dur: 0.05, gain: 0.40 }), 55);
      }

      function playWrong1() {
        // classic buzzer
        AudioLab.osc({ type: "sawtooth", f: 260, fTo: 110, dur: 0.18, gain: 0.50 });
      }

      function playMiss2() {
        // boom + click
        AudioLab.osc({ type: "sawtooth", f: 160, fTo: 70, dur: 0.26, gain: 0.55 });
        setTimeout(() => AudioLab.click({ f: 420, dur: 0.03, gain: 0.22 }), 40);
      }

      function playUi1() {
        AudioLab.click({ f: 740, dur: 0.035, gain: 0.32 });
      }

      async function resume() {
        await AudioLab.resume();
      }

      function play(name) {
        // Guard: iOS will be silent until resume() is called.
        if (name === "shoot" && picks.shoot === 1) playShoot1();
        else if (name === "correct" && picks.correct === 4) playCorrect4();
        else if (name === "wrong" && picks.wrong === 1) playWrong1();
        else if (name === "miss" && picks.miss === 2) playMiss2();
        else if (name === "ui" && picks.ui === 1) playUi1();
      }

      return { resume, play };
    })();

    // ===== Tiny self-tests (console) =====
    // Lightweight sanity checks to catch accidental regressions.
    (function runSelfTests() {
      const modes = ["add", "sub", "mul"];
      for (const mode of modes) {
        for (let i = 0; i < 40; i++) {
          const q = makeQuestion(mode);
          console.assert(typeof q.text === "string", "Question text format");
          console.assert(Array.isArray(q.choices) && q.choices.length === 4, "Choices length 4");

          const uniq = new Set(q.choices);
          console.assert(uniq.size === 4, "Choices are unique");
          console.assert(uniq.has(q.correct), "Choices include correct");

          if (mode === "add") {
            console.assert(Number.isInteger(q.correct) && q.correct >= 0 && q.correct <= 18, "Correct range (add)");
            for (const c of q.choices) {
              console.assert(Number.isInteger(c) && c >= 0 && c <= 18, "Choice range (add)");
            }
            const m = q.text.match(/^\s*(\d+)\s*\+\s*(\d+)\s*$/);
            console.assert(!!m, "Question text parseable (add)");
            if (m) {
              const a = Number(m[1]);
              const b = Number(m[2]);
              console.assert(a >= 0 && a <= 9, "Parsed a range (add)");
              console.assert(b >= 0 && b <= 9, "Parsed b range (add)");
              console.assert(a + b === q.correct, "Parsed correct matches (add)");
            }
          } else if (mode === "sub") {
            console.assert(Number.isInteger(q.correct) && q.correct >= 0 && q.correct <= 20, "Correct range (sub)");
            for (const c of q.choices) {
              console.assert(Number.isInteger(c) && c >= 0 && c <= 20, "Choice range (sub)");
            }
            const m = q.text.match(/^\s*(\d+)\s*-\s*(\d+)\s*$/);
            console.assert(!!m, "Question text parseable (sub)");
            if (m) {
              const a = Number(m[1]);
              const b = Number(m[2]);
              console.assert(a >= 0 && a <= 20, "Parsed a range (sub)");
              console.assert(b >= 0 && b <= a, "Parsed b range (sub)");
              console.assert(a - b === q.correct, "Parsed correct matches (sub)");
            }
          } else {
            console.assert(Number.isInteger(q.correct) && q.correct >= 1 && q.correct <= 81, "Correct range (mul)");
            for (const c of q.choices) {
              console.assert(Number.isInteger(c) && c >= 1 && c <= 81, "Choice range (mul)");
            }
            const m = q.text.match(/^\s*(\d+)\s*×\s*(\d+)\s*$/);
            console.assert(!!m, "Question text parseable (mul)");
            if (m) {
              const a = Number(m[1]);
              const b = Number(m[2]);
              console.assert(a >= 1 && a <= 9, "Parsed a range (mul)");
              console.assert(b >= 1 && b <= 9, "Parsed b range (mul)");
              console.assert(a * b === q.correct, "Parsed correct matches (mul)");
            }
          }

          const sorted = [...q.choices].slice().sort((x, y) => x - y).join(",");
          console.assert(q.choices.join(",") !== sorted || i < 3, "Choices appear shuffled (smoke)");

          const idx = q.choices.indexOf(q.correct);
          console.assert(idx >= 0 && idx < 4, "Correct value has a lane index");
          console.assert(q.choices[idx] === q.correct, "Lane index maps to correct value");
        }
      }
    })();

    // ===== Scenes =====
    class BootScene extends Phaser.Scene {
      constructor() { super("boot"); }
      create() {
        const g = this.add.graphics();

        // Player textures (two realistic fighter silhouettes)
        // Style A: interceptor (clean + sharp)
        g.clear();
        g.fillStyle(0xb6d6f4, 1);
        g.fillTriangle(44, 2, 56, 30, 32, 30);              // nose + upper fuselage
        g.fillRect(32, 26, 24, 18);                           // fuselage body
        g.fillTriangle(8, 34, 32, 28, 32, 46);                // left wing
        g.fillTriangle(80, 34, 56, 28, 56, 46);               // right wing
        g.fillTriangle(28, 48, 36, 40, 36, 54);               // left tail fin
        g.fillTriangle(60, 48, 52, 40, 52, 54);               // right tail fin
        g.fillStyle(0x1d2b42, 1);
        g.fillRoundedRect(40, 12, 8, 10, 3);                  // cockpit
        g.fillStyle(0x6ea3cf, 1);
        g.fillRect(40, 29, 8, 10);                            // intake stripe
        g.fillStyle(0xe2e8f0, 0.75);
        g.lineStyle(2, 0xffffff, 0.35);
        g.strokeTriangle(44, 2, 56, 30, 32, 30);
        g.generateTexture("player_sharp", 88, 56);

        // Style B: strike fighter (heavier + engine glow)
        g.clear();
        g.fillStyle(0x9fb7cf, 1);
        g.fillTriangle(44, 3, 58, 30, 30, 30);                // nose
        g.fillRoundedRect(31, 24, 26, 24, 5);                 // heavy fuselage
        g.fillTriangle(6, 36, 31, 30, 31, 50);                // left wing
        g.fillTriangle(82, 36, 57, 30, 57, 50);               // right wing
        g.fillTriangle(22, 50, 33, 42, 33, 56);               // tail stabilizer L
        g.fillTriangle(66, 50, 55, 42, 55, 56);               // tail stabilizer R
        g.fillStyle(0x172238, 1);
        g.fillRoundedRect(40, 12, 8, 11, 3);                  // cockpit
        g.fillStyle(0xf59e0b, 0.95);
        g.fillCircle(38, 49, 3);                              // engine nozzle L
        g.fillCircle(50, 49, 3);                              // engine nozzle R
        g.fillStyle(0x7dd3fc, 0.45);
        g.fillTriangle(35, 52, 41, 52, 38, 60);               // flame L
        g.fillTriangle(47, 52, 53, 52, 50, 60);               // flame R
        g.lineStyle(2, 0xffffff, 0.25);
        g.strokeRoundedRect(31, 24, 26, 24, 5);
        g.generateTexture("player_flare", 88, 62);

        // Choice texture
        g.clear();
        // Score-matched outline with subtle glow
        g.lineStyle(6, 0xfbbf24, 0.16);
        g.strokeRoundedRect(1, 1, 76, 42, 12);
        g.lineStyle(3, 0xfbbf24, 0.95);
        g.strokeRoundedRect(2, 2, 74, 40, 11);
        g.generateTexture("choice", 78, 44);

        // Bullet texture
        g.clear();
        g.fillStyle(0xf59e0b, 1);
        g.fillRoundedRect(0, 0, 10, 18, 4);
        g.generateTexture("bullet", 10, 18);

        g.destroy();
        this.scene.start("start");
      }
    }

    class StartScene extends Phaser.Scene {
      constructor() { super("start"); }
      create() {
        const { width: w, height: h } = this.scale;

        // Background gradient effect
        const bgGradient = this.add.graphics();
        bgGradient.fillGradientStyle(0x05070f, 0x0b1024, 0x140b2e, 0x05070f);
        bgGradient.fillRect(0, 0, w, h);

        addStarfield(this, w, h, 170);
        
        // Title with glow effect
        const title = this.add.text(w/2, h*0.18, "MATH LANE SHOOTER", {
          fontFamily: FONT_TITLE,
          fontSize: "36px",
          color: "#7dd3fc",
          fontStyle: "bold",
          align: "center",
          shadow: {
            offsetX: 0,
            offsetY: 0,
            color: "#38bdf8",
            blur: 18,
            stroke: true,
            fill: true
          }
        }).setOrigin(0.5);
        
        // Subtitle
        const subtitle = this.add.text(w/2, h*0.24, "計算して、正しいレーンを撃ち抜け", {
          fontFamily: FONT_UI,
          fontSize: "16px",
          color: "#e2e8f0",
          fontStyle: "italic",
          align: "center"
        }).setOrigin(0.5);

        // Ship style toggle
        const shipLabel = this.add.text(w/2, h*0.30, "", {
          fontFamily: FONT_UI,
          fontSize: "15px",
          color: "#dbeafe",
          backgroundColor: "#16233f",
          padding: { left: 12, right: 12, top: 7, bottom: 7 },
          borderRadius: 10
        }).setOrigin(0.5).setInteractive({ useHandCursor: true });
        shipLabel.setDepth(10);

        const updateShipLabel = () => {
          shipLabel.setText(`SHIP: ${currentShip.toUpperCase()} [TAP TO SWITCH]`);
        };
        updateShipLabel();
        shipLabel.on("pointerdown", () => {
          currentShip = currentShip === "sharp" ? "flare" : "sharp";
          SFX.play("ui");
          updateShipLabel();
        });

        // Mode segmented control
        const modeWrap = this.add.container(w/2, h*0.36);
        modeWrap.setDepth(10);
        const modeBg = this.add.rectangle(0, 0, 336, 40, 0x0b1024, 0.85);
        modeBg.setStrokeStyle(2, 0x7dd3fc, 0.35);

        const addBtn = this.add.rectangle(-112, 0, 104, 28, 0x0b1024, 0.9);
        const subBtn = this.add.rectangle(0, 0, 104, 28, 0x0b1024, 0.9);
        const mulBtn = this.add.rectangle(112, 0, 104, 28, 0x0b1024, 0.9);
        addBtn.setInteractive({ useHandCursor: true });
        subBtn.setInteractive({ useHandCursor: true });
        mulBtn.setInteractive({ useHandCursor: true });

        const addText = this.add.text(-112, 0, "足し算", {
          fontFamily: FONT_UI,
          fontSize: "14px",
          color: "#e2e8f0",
          fontStyle: "bold"
        }).setOrigin(0.5);

        const subText = this.add.text(0, 0, "引き算", {
          fontFamily: FONT_UI,
          fontSize: "14px",
          color: "#e2e8f0",
          fontStyle: "bold"
        }).setOrigin(0.5);

        const mulText = this.add.text(112, 0, "掛け算", {
          fontFamily: FONT_UI,
          fontSize: "14px",
          color: "#e2e8f0",
          fontStyle: "bold"
        }).setOrigin(0.5);

        const updateMode = () => {
          const onColor = 0x7dd3fc;
          const offColor = 0x0b1024;
          const onText = "#0b1024";
          const offText = "#e2e8f0";
          if (currentMode === "add") {
            addBtn.fillColor = onColor;
            subBtn.fillColor = offColor;
            mulBtn.fillColor = offColor;
            addText.setColor(onText);
            subText.setColor(offText);
            mulText.setColor(offText);
          } else if (currentMode === "sub") {
            addBtn.fillColor = offColor;
            subBtn.fillColor = onColor;
            mulBtn.fillColor = offColor;
            addText.setColor(offText);
            subText.setColor(onText);
            mulText.setColor(offText);
          } else {
            addBtn.fillColor = offColor;
            subBtn.fillColor = offColor;
            mulBtn.fillColor = onColor;
            addText.setColor(offText);
            subText.setColor(offText);
            mulText.setColor(onText);
          }
        };

        const setMode = (mode) => {
          currentMode = mode;
          SFX.play("ui");
          updateMode();
        };
        addBtn.on("pointerdown", () => setMode("add"));
        subBtn.on("pointerdown", () => setMode("sub"));
        mulBtn.on("pointerdown", () => setMode("mul"));
        addText.setInteractive({ useHandCursor: true }).on("pointerdown", () => setMode("add"));
        subText.setInteractive({ useHandCursor: true }).on("pointerdown", () => setMode("sub"));
        mulText.setInteractive({ useHandCursor: true }).on("pointerdown", () => setMode("mul"));

        modeWrap.add([modeBg, addBtn, subBtn, mulBtn, addText, subText, mulText]);
        updateMode();

        // Instructions panel
        const panel = this.add.rectangle(w/2, h*0.48, w * 0.9, h * 0.35, 0x0b1024, 0.86);
        panel.setStrokeStyle(2, 0x7dd3fc, 0.35);
        
        const helpText = `・4つのレーンに答えが落下
・タップでレーン移動
・左右スワイプでも移動
・素早いダブルタップで発射
・正解で+1、不正解でハート-1
・見逃しでハート-1

STARTでゲーム開始`;

        this.add.text(w/2, h*0.48, helpText, {
          fontFamily: FONT_UI,
          fontSize: "16px",
          color: "#e5e7eb",
          align: "left",
          lineSpacing: 10
        }).setOrigin(0.5);

        // Modern START button
        const btn = this.add.text(w/2, h*0.75, "START", {
          fontFamily: FONT_UI,
          fontSize: "28px",
          color: "#0b0f19",
          backgroundColor: "#7dd3fc",
          padding: { left: 32, right: 32, top: 16, bottom: 16 },
          borderRadius: 16,
          fontStyle: "bold"
        }).setOrigin(0.5).setInteractive({ useHandCursor: true });
        
        // Button animations
        btn.on("pointerover", () => {
          btn.setStyle({ backgroundColor: "#38bdf8", scale: 1.05 });
        });
        
        btn.on("pointerout", () => {
          btn.setStyle({ backgroundColor: "#7dd3fc", scale: 1 });
        });
        
        btn.on("pointerdown", () => {
          btn.setStyle({ backgroundColor: "#0ea5e9", scale: 0.95 });
        });

        const start = async () => {
          await SFX.resume();
          SFX.play("ui");
          this.scene.start("game", { score: 0, lives: 3, ship: currentShip, mode: currentMode });
        };
        btn.on("pointerdown", start);
        
        // Floating animation for title
        this.tweens.add({
          targets: title,
          y: h*0.18 - 5,
          duration: 2000,
          ease: "Sine.easeInOut",
          yoyo: true,
          repeat: -1
        });
        
        // Pulse animation for button
        this.tweens.add({
          targets: btn,
          scaleX: 1.02,
          scaleY: 1.02,
          duration: 1000,
          ease: "Sine.easeInOut",
          yoyo: true,
          repeat: -1
        });
      }
    }

    class GameScene extends Phaser.Scene {
      constructor() {
        super("game");
        this.lane = 1;
        this.laneCenters = [];
        this.player = null;
        this.ship = "sharp";
        this.mode = "sub";
        this.choiceSprites = [];
        this.choiceTexts = [];
        this.roundActive = false;
        this.roundFinished = false;
        this.score = 0;
        this.lives = 3;
        this.roundCount = 0;
        this.speedStep = 0;
        this.currentSpeed = 0;
        this.isPaused = false;
        this.bullets = null;
        this.lastTapTime = 0;
        this.lastTapLane = -1;
        this.lastTapX = 0;
        this.lastTapY = 0;
        this.question = null;
        this.area23Y = 0;
      }

      init(data) {
        this.score = data?.score ?? 0;
        this.lives = data?.lives ?? 3;
        this.ship = data?.ship ?? currentShip;
        this.mode = data?.mode ?? currentMode;
        this.roundCount = 0;
        this.speedStep = 0;
        this.currentSpeed = 0;
        this.isPaused = false;
        this.roundActive = false;
        this.roundFinished = false;
        this.lastTapTime = 0;
        this.lastTapLane = -1;
        this.lastTapX = 0;
        this.lastTapY = 0;
        this.area23Y = 0;
      }

      create() {
        const { width: w, height: h } = this.scale;

        this.cameras.main.setBackgroundColor("#05070f");

        const bg = this.add.graphics();
        bg.fillGradientStyle(0x05070f, 0x0b1024, 0x1a103b, 0x05070f);
        bg.fillRect(0, 0, w, h);
        addStarfield(this, w, h, 140);

        // Lanes
        const laneW = w / 4;
        this.laneCenters = [0,1,2,3].map(i => (i + 0.5) * laneW);

        const lanesG = this.add.graphics();
        lanesG.lineStyle(2, 0x1f2a44, 0.8);
        for (let i = 1; i <= 3; i++) lanesG.lineBetween(i*laneW, 80, i*laneW, h);
        lanesG.lineStyle(2, 0x0f172a, 1);
        lanesG.lineBetween(0, 80, w, 80);

        const hudMarginX = 20;
        const hudGap = 10;
        const hudTopY = 132;
        const hudPanelHeight = 52;
        const hudPanelWidth = (w - (hudMarginX * 2) - (hudGap * 2)) / 3;
        const scorePanelWidth = hudPanelWidth;
        const speedPanelWidth = hudPanelWidth;
        const livesPanelWidth = hudPanelWidth;

        const compactLevel = h < 700 ? 2 : (h < 780 ? 1 : 0);
        const questionPanelHeight = compactLevel === 2 ? 92 : (compactLevel === 1 ? 100 : 110);
        const questionFontSize = compactLevel === 2 ? 52 : (compactLevel === 1 ? 56 : 60);
        const cornerLen = compactLevel === 2 ? 16 : (compactLevel === 1 ? 20 : 24);
        const cornerOffset = compactLevel === 2 ? 6 : (compactLevel === 1 ? 7 : 8);
        const questionPanelWidth = Math.min(520, Math.max(300, w * 0.72));
        const questionPanelX = w / 2;
        const questionGapFromHud = 10;
        const hudBottomY = hudTopY + (hudPanelHeight / 2);
        const questionPanelY = Math.round(hudBottomY + questionGapFromHud + (questionPanelHeight / 2));
        const questionPanelLeft = questionPanelX - (questionPanelWidth / 2);
        const questionPanelRight = questionPanelX + (questionPanelWidth / 2);
        const questionPanelTop = questionPanelY - (questionPanelHeight / 2);
        const questionPanelBottom = questionPanelY + (questionPanelHeight / 2);

        // Question panel (below HUD)
        const questionPanelG = this.add.graphics();
        questionPanelG.fillStyle(0x041726, 0.5);
        questionPanelG.fillRoundedRect(questionPanelLeft, questionPanelTop, questionPanelWidth, questionPanelHeight, 12);
        questionPanelG.lineStyle(3, 0x00ffff, 0.9);
        questionPanelG.strokeRoundedRect(questionPanelLeft, questionPanelTop, questionPanelWidth, questionPanelHeight, 12);

        questionPanelG.lineStyle(4, 0x67e8f9, 0.95);
        // top-left
        questionPanelG.lineBetween(questionPanelLeft + cornerOffset, questionPanelTop + cornerOffset, questionPanelLeft + cornerOffset + cornerLen, questionPanelTop + cornerOffset);
        questionPanelG.lineBetween(questionPanelLeft + cornerOffset, questionPanelTop + cornerOffset, questionPanelLeft + cornerOffset, questionPanelTop + cornerOffset + cornerLen);
        // top-right
        questionPanelG.lineBetween(questionPanelRight - cornerOffset, questionPanelTop + cornerOffset, questionPanelRight - cornerOffset - cornerLen, questionPanelTop + cornerOffset);
        questionPanelG.lineBetween(questionPanelRight - cornerOffset, questionPanelTop + cornerOffset, questionPanelRight - cornerOffset, questionPanelTop + cornerOffset + cornerLen);
        // bottom-left
        questionPanelG.lineBetween(questionPanelLeft + cornerOffset, questionPanelBottom - cornerOffset, questionPanelLeft + cornerOffset + cornerLen, questionPanelBottom - cornerOffset);
        questionPanelG.lineBetween(questionPanelLeft + cornerOffset, questionPanelBottom - cornerOffset, questionPanelLeft + cornerOffset, questionPanelBottom - cornerOffset - cornerLen);
        // bottom-right
        questionPanelG.lineBetween(questionPanelRight - cornerOffset, questionPanelBottom - cornerOffset, questionPanelRight - cornerOffset - cornerLen, questionPanelBottom - cornerOffset);
        questionPanelG.lineBetween(questionPanelRight - cornerOffset, questionPanelBottom - cornerOffset, questionPanelRight - cornerOffset, questionPanelBottom - cornerOffset - cornerLen);

        this.questionText = this.add.text(questionPanelX, questionPanelY, "", {
          fontFamily: FONT_ENEMY,
          fontSize: `${questionFontSize}px`,
          color: "#99f6ff",
          stroke: "#0b1024",
          strokeThickness: 3,
          fontStyle: "bold",
          shadow: {
            offsetX: 0,
            offsetY: 0,
            color: "#00ffff",
            blur: 22,
            stroke: false,
            fill: true
          }
        }).setOrigin(0.5);

        // Score panel (top row)
        const scorePanelX = hudMarginX + (scorePanelWidth / 2);
        const scorePanelY = hudTopY;
        const scorePanel = this.add.rectangle(scorePanelX, scorePanelY, scorePanelWidth, hudPanelHeight, 0x0b1024, 0.8);
        scorePanel.setStrokeStyle(2, 0xff8800, 0.9);

        const scoreFontSize = Math.max(20, Math.min(30, Math.round(scorePanelWidth * 0.15)));

        this.scoreText = this.add.text(scorePanelX, scorePanelY, "SCR: 0", {
          fontFamily: FONT_ENEMY,
          fontSize: `${scoreFontSize}px`,
          color: "#ffb347",
          fontStyle: "bold"
        }).setOrigin(0.5);

        const scoreAccent = this.add.graphics();
        scoreAccent.lineStyle(3, 0xff8800, 1);
        scoreAccent.lineBetween(hudMarginX, hudTopY - (hudPanelHeight / 2), hudMarginX, hudTopY + (hudPanelHeight / 2));

        // Speed panel (top row)
        const speedPanelLeft = hudMarginX + scorePanelWidth + hudGap;
        const speedPanelX = speedPanelLeft + (speedPanelWidth / 2);
        const speedPanelY = hudTopY;
        const speedPanel = this.add.rectangle(speedPanelX, speedPanelY, speedPanelWidth, hudPanelHeight, 0x0b1024, 0.8);
        speedPanel.setStrokeStyle(2, 0x00ffff, 0.9);

        const speedFontSize = Math.max(18, Math.min(28, Math.round(speedPanelWidth * 0.17)));

        this.speedText = this.add.text(speedPanelX, speedPanelY, "SPD: 0", {
          fontFamily: FONT_ENEMY,
          fontSize: `${speedFontSize}px`,
          color: "#67e8f9",
          fontStyle: "bold"
        }).setOrigin(0.5);

        const speedAccent = this.add.graphics();
        speedAccent.lineStyle(3, 0x00ffff, 1);
        speedAccent.lineBetween(speedPanelLeft, hudTopY - (hudPanelHeight / 2), speedPanelLeft, hudTopY + (hudPanelHeight / 2));

        // Lives panel (top row)
        const livesPanelLeft = speedPanelLeft + speedPanelWidth + hudGap;
        const livesPanelX = livesPanelLeft + (livesPanelWidth / 2);
        const livesPanelY = hudTopY;
        const livesPanel = this.add.rectangle(livesPanelX, livesPanelY, livesPanelWidth, hudPanelHeight, 0x0b1024, 0.8);
        livesPanel.setStrokeStyle(2, 0x00ffaa, 0.9);

        const livesFontSize = scoreFontSize;
        const livesLabelX = livesPanelX - (livesPanelWidth / 2) + 14;
        this.livesText = this.add.text(livesLabelX, livesPanelY, "LIF:", {
          fontFamily: FONT_ENEMY,
          fontSize: `${livesFontSize}px`,
          color: "#6ee7b7",
          fontStyle: "bold"
        }).setOrigin(0, 0.5);

        this.lifeBars = [];
        const lifeBarWidth = Math.max(20, Math.min(30, Math.round(livesPanelWidth * 0.12)));
        const lifeBarHeight = 10;
        const lifeBarGapY = 15;
        const lifeBarStartX = livesPanelX + (livesPanelWidth / 2) - lifeBarWidth - 14;
        const lifeBarTopY = livesPanelY - lifeBarGapY;
        for (let i = 0; i < 3; i++) {
          const bar = this.add.rectangle(lifeBarStartX, lifeBarTopY + i * lifeBarGapY, lifeBarWidth, lifeBarHeight, 0x00ffaa, 0.95);
          bar.setStrokeStyle(1, 0x99ffe0, 0.9);
          this.lifeBars.push(bar);
        }

        const livesAccent = this.add.graphics();
        livesAccent.lineStyle(3, 0x00ffaa, 1);
        livesAccent.lineBetween(livesPanelLeft + livesPanelWidth, hudTopY - (hudPanelHeight / 2), livesPanelLeft + livesPanelWidth, hudTopY + (hudPanelHeight / 2));

        this.updateLivesDisplay();

        // Debug (helps verify lane/answer selection)
        this.debugText = this.add.text(14, h - 26, "", {
          fontFamily: FONT_UI,
          fontSize: "12px",
          color: "#64748b"
        });

        // Modern pause button
        this.pauseBtn = this.add.text(w - 30, 32, "II", {
          fontFamily: FONT_UI,
          fontSize: "24px",
          color: "#e5e7eb",
          backgroundColor: "#1e293b",
          padding: { left: 12, right: 12, top: 8, bottom: 8 },
          borderRadius: 8
        }).setOrigin(0.5).setInteractive({ useHandCursor: true });
        
        // Pause button hover effects
        this.pauseBtn.on("pointerover", () => {
          this.pauseBtn.setStyle({ backgroundColor: "#334155", scale: 1.1 });
        });
        
        this.pauseBtn.on("pointerout", () => {
          this.pauseBtn.setStyle({ backgroundColor: "#1e293b", scale: 1 });
        });

        this.pauseBtn.on("pointerdown", () => {
          SFX.play("ui");
          if (this.isPaused) return;
          this.isPaused = true;
          this.scene.launch("pause");
          this.scene.pause();
        });

        // Bullets
        this.bullets = this.physics.add.group({ allowGravity: false });

        // Player
        this.lane = 1;
        const playerTex = this.ship === "flare" ? "player_flare" : "player_sharp";
        this.player = this.physics.add.image(this.laneCenters[this.lane], h - 70, playerTex);
        this.player.setImmovable(true);
        this.player.body.allowGravity = false;

        // Score zones (Area3/Area2/Area1) boundary lines
        this.judgeY = h - 95;
        this.area23Y = this.judgeY / 2;
        const lineG = this.add.graphics();

        // Thin boundary lines (no glow)
        lineG.lineStyle(2, 0x06b6d4, 0.45);
        lineG.lineBetween(0, this.area23Y, w, this.area23Y);
        lineG.lineBetween(0, this.judgeY, w, this.judgeY);

        // Keep reference for future updates
        this.judgeLine = lineG;
        
        // Judge label with modern styling
        this.judgeLabel = this.add.text(w - 20, this.judgeY - 20, "LOCK LINE", {
          fontFamily: FONT_UI,
          fontSize: "12px",
          color: "#7dd3fc",
          fontStyle: "bold",
          backgroundColor: "#05070f",
          padding: { left: 8, right: 8, top: 4, bottom: 4 },
          borderRadius: 4
        }).setOrigin(1, 0.5);
        
        // Pulsing animation for judge line
        this.tweens.add({
          targets: this.judgeLabel,
          alpha: 0.6,
          duration: 1000,
          ease: "Sine.easeInOut",
          yoyo: true,
          repeat: -1
        });

        // Input
        this.setupInput();

        // Start
        this.newRound();
      }

      setupInput() {
        const { width: w } = this.scale;
        const laneW = w / 4;

        let downX = 0;
        let downY = 0;
        let downTime = 0;

        const DOUBLE_TAP_MS = 420;
        const DOUBLE_TAP_DIST = 70; // px; allows slight drift between taps

        this.input.on("pointerdown", (p) => {
          downX = p.x;
          downY = p.y;
          downTime = performance.now();

          const targetLane = Phaser.Math.Clamp(Math.floor(p.x / laneW), 0, 3);
          const now = performance.now();

          const isDoubleTap =
            (now - this.lastTapTime) <= DOUBLE_TAP_MS &&
            Phaser.Math.Distance.Between(p.x, p.y, this.lastTapX, this.lastTapY) <= DOUBLE_TAP_DIST;

          if (isDoubleTap) {
            this.setLane(targetLane);
            SFX.play("shoot");
            this.shootAtLane(targetLane);
            if (this.debugText) {
              const chosenValue = this.question?.choices?.[targetLane];
              const ok = (chosenValue === this.question?.correct);
              this.debugText.setText(`SHOT lane=${targetLane+1} value=${chosenValue} correct=${this.question?.correct} -> ${ok ? "OK" : "NG"}`);
            }
            this.lastTapTime = 0;
            this.lastTapLane = -1;
            this.lastTapX = 0;
            this.lastTapY = 0;
          } else {
            this.setLane(targetLane);
            this.lastTapTime = now;
            this.lastTapLane = targetLane;
            this.lastTapX = p.x;
            this.lastTapY = p.y;
          }
        });

        this.input.on("pointerup", (p) => {
          const dx = p.x - downX;
          const dy = p.y - downY;
          const dt = performance.now() - downTime;

          const SWIPE_MIN_X = 40;
          const MAX_Y = 60;
          const MAX_TIME = 350;

          if (dt <= MAX_TIME && Math.abs(dy) <= MAX_Y && Math.abs(dx) >= SWIPE_MIN_X) {
            // Prevent swipe from chaining into a double tap
            this.lastTapTime = 0;
            this.lastTapLane = -1;
            this.lastTapX = 0;
            this.lastTapY = 0;

            if (dx > 0) this.moveLane(+1);
            else this.moveLane(-1);
            return;
          }

          
        });
      }

      moveLane(delta) {
        this.setLane(Phaser.Math.Clamp(this.lane + delta, 0, 3));
      }

      setLane(l) {
        if (l === this.lane) return;
        this.lane = l;
        this.tweens.add({ targets: this.player, x: this.laneCenters[this.lane], duration: 120, ease: "Sine.easeOut" });
      }

      clearChoices() {
        for (const s of this.choiceSprites) s.destroy();
        for (const t of this.choiceTexts) t.destroy();
        this.choiceSprites = [];
        this.choiceTexts = [];
      }

      getAreaByImpactY(impactY) {
        if (!Number.isFinite(impactY)) return 1;
        if (impactY < this.area23Y) return 3;
        if (impactY < this.judgeY) return 2;
        return 1;
      }

      getScoreByImpactArea(impactY) {
        return this.getAreaByImpactY(impactY);
      }

      shootAtLane(targetLane) {
        // Double-tap selection should NEVER be counted as "miss".
        if (this.roundFinished || this.isPaused || !this.bullets) return;
        if (!this.choiceSprites || this.choiceSprites.length < 4) return;

        // Lock the round immediately.
        this.roundActive = false;
        this.roundFinished = true;

        const { height: h } = this.scale;
        const x = this.laneCenters[targetLane];
        const startY = (this.player?.y ?? (h - 70)) - ((this.player?.displayHeight ?? 52) * 0.42);

        const choice = this.choiceSprites[targetLane];
        const targetY = choice?.y ?? 120;

        const b = this.bullets.create(x, startY, "bullet");
        b.setDataEnabled();
        if (b.body) b.body.setSize(24, 24, true);

        const distance = Math.max(0, startY - targetY);
        const speed = 900;
        const duration = Phaser.Math.Clamp((distance / speed) * 1000, 80, 260);

        this.tweens.add({
          targets: b,
          y: targetY,
          duration,
          ease: "Sine.easeIn",
          onComplete: () => {
            if (b && b.active) b.destroy();
            // Decide correctness from the round data (stable even if sprites are destroyed)
            const chosenValue = this.question?.choices?.[targetLane];
            const isCorrect = (chosenValue === this.question?.correct);
            this.finishRound(isCorrect, targetY);
          }
        });
      }

      // Called after a shot OR collision; always progresses to next question.
      finishRound(isCorrect, impactY = null, forcedScore = null) {
        if (this.bullets) this.bullets.clear(true, true);
        this.clearChoices();

        if (isCorrect) {
          let plus = Number.isFinite(forcedScore) ? forcedScore : this.getScoreByImpactArea(impactY);
          plus = Phaser.Math.Clamp(Math.round(plus), 1, 3);
          this.score += plus;
          this.speedStep += 1;
          SFX.play("correct");
          const correctLabel = plus === 1 ? "CORRECT" : `CORRECT +${plus}`;
          this.flash(correctLabel, 0x4ade80);
        } else {
          this.lives -= 1;
          SFX.play("wrong");
          this.flash("WRONG!", 0xf87171);
        }

        this.time.delayedCall(420, () => this.newRound());
      }

      // Back-compat: bullet overlap can still call this.
      resolveChoiceHit(isCorrect, impactY = null) {
        if (this.roundFinished) return;
        this.roundFinished = true;
        this.roundActive = false;
        this.finishRound(!!isCorrect, impactY);
      }

      newRound() {
        if (this.lives <= 0) {
          this.scene.start("gameover", { score: this.score });
          return;
        }

        this.roundCount += 1;
        this.roundFinished = false;
        this.roundActive = true;

        if (this.bullets) this.bullets.clear(true, true);
        this.clearChoices();

        this.question = makeQuestion(this.mode);
        this.questionText.setText(this.question.text);
        this.scoreText.setText(`SCR: ${this.score}`);
        this.updateLivesDisplay();

        const { height: h } = this.scale;

        const baseSpeed = 170;
        const fallSpeed = Math.min(420, baseSpeed + this.speedStep * 10);
        this.currentSpeed = fallSpeed;
        this.speedText.setText(`SPD: ${Math.round(fallSpeed)}`);

        for (let i = 0; i < 4; i++) {
          const value = this.question.choices[i];
          const isCorrect = value === this.question.correct;

          const s = this.physics.add.image(this.laneCenters[i], -60, "choice");
          s.body.allowGravity = false;
          s.setVelocityY(fallSpeed);
          s.setDataEnabled();
          s.data.set("value", value);
          s.data.set("correct", isCorrect);

          // More forgiving bodies (touch-friendly)
          if (s.body) s.body.setSize(96, 64, true);

          const t = this.add.text(s.x, s.y, String(value), {
            fontFamily: FONT_ENEMY,
            fontSize: "32px",
            color: "#fbbf24",
            stroke: "#0b1024",
            strokeThickness: 2,
            shadow: {
              offsetX: 0,
              offsetY: 1,
              color: "#0b1024",
              blur: 6,
              stroke: false,
              fill: true
            },
            fontStyle: "bold"
          }).setOrigin(0.5);

          this.choiceSprites.push(s);
          this.choiceTexts.push(t);

          // Bullet overlap check (optional; shootAtLane resolves without needing collision)
          this.physics.add.overlap(this.bullets, s, (bullet, choice) => {
            // If the round is already being resolved (e.g., via shootAtLane), ignore overlaps.
            if (this.roundFinished) return;
            bullet.destroy();
            this.resolveChoiceHit(choice.data.get("correct"), choice.y);
          });
        }

        this.missCheckY = h + 30;
        // If you want to judge exactly on the line, keep judgeY stable
        // (set in create).
      }

      updateLivesDisplay() {
        const activeStartIndex = Math.max(0, 3 - this.lives);
        for (let i = 0; i < this.lifeBars.length; i++) {
          const active = i >= activeStartIndex;
          this.lifeBars[i].setFillStyle(active ? 0x00ffaa : 0x0b1024, active ? 0.95 : 0.85);
          this.lifeBars[i].setStrokeStyle(1, active ? 0x99ffe0 : 0xffffff, active ? 0.9 : 0.95);
        }
      }

      flash(label, color) {
        const { width: w, height: h } = this.scale;
        
        // Background panel for feedback
        const panel = this.add.rectangle(w/2, h*0.35, w * 0.8, 80, 0x0b1024, 0.9);
        panel.setStrokeStyle(3, color, 0.8);
        
        // Feedback text with glow effect
        const txt = this.add.text(w/2, h*0.35, label, {
          fontFamily: FONT_UI,
          fontSize: "36px",
          color: "#ffffff",
          fontStyle: "bold",
          shadow: {
            offsetX: 0,
            offsetY: 0,
            color: Phaser.Display.Color.IntegerToColor(color).rgba,
            blur: 20,
            stroke: true,
            fill: true
          }
        }).setOrigin(0.5);
        
        // Scale animation
        txt.setScale(0);
        panel.setScale(0);
        
        this.tweens.add({
          targets: [panel, txt],
          scaleX: 1,
          scaleY: 1,
          duration: 200,
          ease: "Back.easeOut"
        });
        
        // Fade out animation
        this.tweens.add({
          targets: [panel, txt],
          alpha: 0,
          duration: 400,
          delay: 600,
          ease: "Sine.easeIn",
          onComplete: () => {
            panel.destroy();
            txt.destroy();
          }
        });

        // Update UI with animation
        this.scoreText.setText(`SCR: ${this.score}`);
        this.updateLivesDisplay();
        
        // Pulse effect on score/lives panels
        if (label.includes("CORRECT")) {
          this.tweens.add({
            targets: this.scoreText,
            scaleX: 1.2,
            scaleY: 1.2,
            duration: 200,
            ease: "Sine.easeOut",
            yoyo: true
          });
        } else if (label.includes("WRONG") || label.includes("MISS")) {
          this.tweens.add({
            targets: this.lifeBars,
            scaleX: 1.2,
            scaleY: 1.2,
            duration: 200,
            ease: "Sine.easeOut",
            yoyo: true
          });
        }
      }

      update() {
        // Keep texts aligned to sprites always
        for (let i = 0; i < this.choiceSprites.length; i++) {
          const s = this.choiceSprites[i];
          const t = this.choiceTexts[i];
          if (s && t) t.setPosition(s.x, s.y);
        }

        // Auto-judge on the judge line: if you are in the correct lane when choices reach the line, it's correct.
        if (this.roundActive && !this.roundFinished) {
          const lead = this.choiceSprites[0];
          if (lead && lead.y >= this.judgeY) {
            this.roundActive = false;
            this.roundFinished = true;

            const chosenValue = this.question?.choices?.[this.lane];
            const isCorrect = (chosenValue === this.question?.correct);
            if (this.debugText) this.debugText.setText(`AUTO lane=${this.lane+1} value=${chosenValue} correct=${this.question?.correct} -> ${isCorrect ? "OK" : "NG"}`);

            if (isCorrect) this.finishRound(true, null, 1);
            else this.finishRound(false);
          }
        }

        // Only check misses during active falling (fallback)
        if (this.roundActive) {
          const allPast = this.choiceSprites.length > 0 && this.choiceSprites.every(s => s.y > this.missCheckY);
          if (allPast) {
            this.roundActive = false;
            this.roundFinished = true; // prevents double resolving
            if (this.bullets) this.bullets.clear(true, true);
            this.clearChoices();
            this.lives -= 1;
            SFX.play("miss");
            this.flash("MISS!", 0xfbbf24);
            if (this.debugText) this.debugText.setText("MISS: choices passed bottom before selection");
            this.time.delayedCall(420, () => this.newRound());
          }
        }

        // Cleanup bullets that go off-screen
        if (this.bullets) {
          this.bullets.children.each((b) => {
            if (b && b.active && b.y < -40) b.destroy();
          });
        }
      }
    }

    class PauseScene extends Phaser.Scene {
      constructor() { super("pause"); }
      create() {
        const { width: w, height: h } = this.scale;

        this.add.rectangle(w/2, h/2, w, h, 0x000000, 0.55);

        this.add.text(w/2, h*0.32, "PAUSED", {
          fontFamily: FONT_UI,
          fontSize: "40px",
          color: "#e5e7eb"
        }).setOrigin(0.5);

        const resumeBtn = this.add.text(w/2, h*0.50, "RESUME", {
          fontFamily: FONT_UI,
          fontSize: "26px",
          color: "#0b0f19",
          backgroundColor: "#4ade80",
          padding: { left: 18, right: 18, top: 10, bottom: 10 }
        }).setOrigin(0.5).setInteractive({ useHandCursor: true });

        const quitBtn = this.add.text(w/2, h*0.62, "QUIT", {
          fontFamily: FONT_UI,
          fontSize: "26px",
          color: "#0b0f19",
          backgroundColor: "#7dd3fc",
          padding: { left: 22, right: 22, top: 10, bottom: 10 }
        }).setOrigin(0.5).setInteractive({ useHandCursor: true });

        const pauseHelp = `RESUMEで続行
QUITでやめる`;
        this.add.text(w/2, h*0.76, pauseHelp, {
          fontFamily: FONT_UI,
          fontSize: "16px",
          color: "#cbd5e1",
          align: "center",
          lineSpacing: 8
        }).setOrigin(0.5);

        const resume = () => {
          const game = this.scene.get("game");
          game.isPaused = false;
          this.scene.stop();
          this.scene.resume("game");
        };

        const quit = () => {
          const game = this.scene.get("game");
          game.isPaused = false;
          this.scene.stop("game");
          this.scene.stop();
          this.scene.start("start");
        };

        resumeBtn.on("pointerdown", resume);
        quitBtn.on("pointerdown", quit);
      }
    }

    class GameOverScene extends Phaser.Scene {
      constructor() { super("gameover"); }
      init(data) {
        this.finalScore = data?.score ?? 0;
      }
      create() {
        const { width: w, height: h } = this.scale;

        // Background overlay
        const overlay = this.add.rectangle(w/2, h/2, w, h, 0x0f172a, 0.8);
        
        // Panel background
        const panel = this.add.rectangle(w/2, h/2, w * 0.85, h * 0.7, 0x0b1024, 0.9);
        panel.setStrokeStyle(2, 0x7dd3fc, 0.5);
        
        // GAME OVER title with glow effect
        const title = this.add.text(w/2, h*0.25, "GAME OVER", {
          fontFamily: FONT_TITLE,
          fontSize: "48px",
          color: "#ef4444",
          fontStyle: "bold",
          shadow: {
            offsetX: 0,
            offsetY: 0,
            color: "#ef4444",
            blur: 20,
            stroke: true,
            fill: true
          }
        }).setOrigin(0.5);
        
        // Score with animation
        const scoreText = this.add.text(w/2, h*0.42, `SCORE: ${this.finalScore}`, {
          fontFamily: FONT_UI,
          fontSize: "32px",
          color: "#fbbf24",
          fontStyle: "bold"
        }).setOrigin(0.5);
        
        // Score animation
        this.tweens.add({
          targets: scoreText,
          scaleX: 1.1,
          scaleY: 1.1,
          duration: 600,
          ease: "Sine.easeInOut",
          yoyo: true,
          repeat: -1
        });
        
        // Modern retry button
        const btn = this.add.text(w/2, h*0.65, "RETRY", {
          fontFamily: FONT_UI,
          fontSize: "24px",
          color: "#0b0f19",
          backgroundColor: "#7dd3fc",
          padding: { left: 24, right: 24, top: 14, bottom: 14 },
          borderRadius: 12
        }).setOrigin(0.5).setInteractive({ useHandCursor: true });
        
        // Button hover effects
        btn.on("pointerover", () => {
          btn.setStyle({ backgroundColor: "#38bdf8", scale: 1.05 });
        });
        
        btn.on("pointerout", () => {
          btn.setStyle({ backgroundColor: "#7dd3fc", scale: 1 });
        });
        
        btn.on("pointerdown", () => {
          btn.setStyle({ backgroundColor: "#0ea5e9", scale: 0.95 });
        });

        const retry = () => this.scene.start("game", { score: 0, lives: 3 });
        btn.on("pointerdown", retry);
        this.input.once("pointerdown", retry);

        // Subtle hint text
        this.add.text(w/2, h*0.80, "Tap to retry", {
          fontFamily: FONT_UI,
          fontSize: "14px",
          color: "#64748b",
          fontStyle: "italic"
        }).setOrigin(0.5);
        
        // Fade in animation
        overlay.setAlpha(0);
        panel.setAlpha(0);
        title.setAlpha(0);
        scoreText.setAlpha(0);
        btn.setAlpha(0);
        
        this.tweens.add({
          targets: [overlay, panel],
          alpha: 1,
          duration: 400,
          ease: "Sine.easeOut"
        });
        
        this.tweens.add({
          targets: [title, scoreText, btn],
          alpha: 1,
          duration: 600,
          delay: 200,
          ease: "Sine.easeOut"
        });
      }
    }

    let activeGame = null;
    let appHeightSyncRaf = 0;

    function applyAppHeight() {
      const viewportHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;
      if (!viewportHeight) return;
      const nextHeight = Math.round(viewportHeight);
      document.documentElement.style.setProperty("--app-height", `${nextHeight}px`);
      if (activeGame?.scale) {
        activeGame.scale.refresh();
      }
    }

    function syncAppHeight(immediate = false) {
      if (immediate) {
        if (appHeightSyncRaf) {
          window.cancelAnimationFrame(appHeightSyncRaf);
          appHeightSyncRaf = 0;
        }
        applyAppHeight();
        return;
      }

      if (appHeightSyncRaf) return;
      appHeightSyncRaf = window.requestAnimationFrame(() => {
        appHeightSyncRaf = 0;
        applyAppHeight();
      });
    }

    window.addEventListener("resize", syncAppHeight);
    window.addEventListener("orientationchange", syncAppHeight);
    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", syncAppHeight);
      window.visualViewport.addEventListener("scroll", syncAppHeight);
    }

    // ===== Game Config =====
    const config = {
      type: Phaser.AUTO,
      parent: "game",
      backgroundColor: "#05070f",
      physics: {
        default: "arcade",
        arcade: { debug: false }
      },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: 390,
        height: 844
      },
      scene: [BootScene, StartScene, GameScene, PauseScene, GameOverScene]
    };

    async function waitForGameFonts(timeoutMs = 2500) {
      if (!document.fonts || typeof document.fonts.load !== "function") return;

      const timer = new Promise(resolve => {
        window.setTimeout(() => resolve("timeout"), timeoutMs);
      });

      try {
        const fontsReady = Promise.all([
          document.fonts.load("700 60px Rajdhani"),
          document.fonts.load("700 56px Rajdhani"),
          document.fonts.load("700 52px Rajdhani"),
          document.fonts.load("700 32px Rajdhani")
        ]).then(() => "loaded");

        const result = await Promise.race([fontsReady, timer]);
        if (result === "timeout") {
          console.warn(`[font] Rajdhani load timeout after ${timeoutMs}ms; continue bootstrap.`);
        }
      } catch (err) {
        console.warn("[font] Failed to load Rajdhani before bootstrap.", err);
      }
    }

    async function bootstrapGame() {
      if (activeGame) return;
      syncAppHeight(true);
      await waitForGameFonts(2500);
      activeGame = new Phaser.Game(config);
      syncAppHeight(true);
    }

    if (document.readyState === "loading") {
      window.addEventListener("DOMContentLoaded", () => {
        bootstrapGame();
      }, { once: true });
    } else {
      bootstrapGame();
    }
  </script>
</body>
</html>


























